package com.graphs.code;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Scanner;

class StressTest {
    public static void main(String[] args) {
        Date d = new Date();
        //tests the getIncrement() method (doesn't work for years yet).
        for(int i = 0; i < 366; i++) {
            System.out.println(d);
            d = d.getIncrement();
        }
    }
}

public class Main {

    public static String DATA_PATH = "";
    public static Scanner scanner = new Scanner(System.in);

    //Date is Date, Integer is value of day
    static HashMap<Date, Double> data = new HashMap<>();
    static HashMap<Date, Double> newData = new HashMap<>();

    static int dayCounter = 0;

    static double lastVal = 0;
    static double currentVal = lastVal;

    static Date lastDate = getFirstDate();
    static Date currentDate = lastDate;

    static Date endDate = getLastDate();

    static double[] valRange = null;

    static int[] freezeTime = new int[2];

    static boolean cycleStarted = false;
    static boolean cycleFinished = false;

    static Date cycleStart = null;

    public static void main(String[] args) {
        populate();

        while(true) {

            if(!lastDate.isConsecutive(currentDate)) {
                if(valRange == null) {
                    valRange = new double[2];
                    valRange[0] = currentVal;
                    freezeTime[0] = dayCounter;
                    cycleStarted = true;
                }
                else {
                    valRange[1] = currentVal;
                    freezeTime[1] = dayCounter;
                    cycleStarted = false;
                    cycleFinished = true;
                }
            }

            if(cycleFinished) {
                int duration = Math.abs(freezeTime[1] - freezeTime[0]);
                double avg = findAvgTemp(duration, valRange[0], valRange[1]);
                //add all of the missing days using the average
                Date instanceDate = cycleStart;
                for(int i = 0; i < duration; i++) {
                    newData.put(instanceDate, avg);
                    instanceDate = instanceDate.getIncrement();
                }
            }

            //if nothing is wrong and the dates are in order
            if(!cycleStarted) {
                newData.put(currentDate, currentVal);
            }

            if(currentDate.equals(endDate)) {
                break;
            }

            lastDate = currentDate;
            currentDate = currentDate.getIncrement();

            lastVal = currentVal;
            //TODO fix NullPointerException
            currentVal = data.get(currentDate);

            dayCounter++;
        }

        System.out.println(data);
        System.out.println(newData);

    }

    //replace with the real thing later
    public static double findAvgTemp(int duration, double num1, double num2) {
        return (num1 + num2) / ((double) duration);
    }

    public static void populate() {
        //gets information from a text file
        try {
            Scanner fileReader = new Scanner(new File(DATA_PATH));
            String[] tokens;

            while(fileReader.hasNextLine()) {
                tokens = fileReader.nextLine().split("->");
                data.put(getDate(tokens[0].trim()), Double.parseDouble(tokens[1].trim()));
            }

        } catch(IOException e) {
            System.out.println("No path configured. Find the path to the \"Data.txt\" file and paste it here. (Full location, not relative class)");
            System.out.print("Path: ");
            DATA_PATH = scanner.nextLine().trim().toLowerCase();
            //retry the process with the new path
            populate();
        }
    }

    public static Date getLastDate() {
        try {
            Files.write(Paths.get(DATA_PATH), reverse(new Scanner(new File(DATA_PATH))).getBytes(), StandardOpenOption.WRITE);
            Date date = getFirstDate();
            Files.write(Paths.get(DATA_PATH), reverse(new Scanner(new File(DATA_PATH))).getBytes(), StandardOpenOption.WRITE);
            return date;
        } catch(IOException ioe) {
            System.out.println("No path configured. Find the path to the \"Data.txt\" file and paste it here. (Full location, not relative class)");
            System.out.print("Path: ");
            DATA_PATH = scanner.nextLine().trim().toLowerCase();
            return getLastDate();
        }
    }

    private static String reverse(Scanner scanner) {
        ArrayList<String> listOfTokens = new ArrayList<>();
        StringBuilder sb = new StringBuilder();

        while(scanner.hasNextLine()) {
            listOfTokens.add(scanner.nextLine());
        }

        for(int i = listOfTokens.size() - 1; i >= 0; i--) {
            sb.append(listOfTokens.get(i));
            if(i != 0) {
                sb.append("\n");
            }
        }
        return sb.toString();
    }

    public static Date getDate(String dateAsStr) {
        String[] tokens = dateAsStr.split("/");
        return new Date(Integer.parseInt(tokens[0].trim()),
                Integer.parseInt(tokens[1].trim()),
                Integer.parseInt(tokens[2].trim()));
    }

    public static Date getFirstDate() {
        try {
            Scanner fileReader = new Scanner(new File(DATA_PATH));
            return getDate(fileReader.nextLine().split("->")[0].trim());
        } catch(IOException ioe) {
            System.out.println("No path configured. Find the path to the \"Data.txt\" file and paste it here. (Full location, not relative class)");
            System.out.print("Path: ");
            DATA_PATH = scanner.nextLine().trim().toLowerCase();
            return getFirstDate();
        }
    }

}